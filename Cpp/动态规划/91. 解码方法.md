一条包含字母 A-Z 的消息通过以下方式进行了编码：

'A' -> 1
'B' -> 2
...
'Z' -> 26
给定一个只包含数字的非空字符串，请计算解码方法的总数。

题目数据保证答案肯定是一个 32 位的整数。

 

示例 1：

输入：s = "12"
输出：2
解释：它可以解码为 "AB"（1 2）或者 "L"（12）。
示例 2：

输入：s = "226"
输出：3
解释：它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。
示例 3：

输入：s = "0"
输出：0
示例 4：

输入：s = "1"
输出：1
示例 5：

输入：s = "2"
输出：1

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/decode-ways
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

Solution: 
动态规划, dp[i]为每次新加入一个字符s[i]时的可能的所有组合
需要分很多种情况谈论

1. dp[i] == '0', 字符0不能作为前缀,只能和前面的字符结合起来,  对于s[i-1], 它也只能和'0'结合起来, s[i-2]还的满足是1, 或者2, 其他字符都是不行的所有
    $$
    dp[i]  = dp[i - 2]
    $$
    

2. dp[i] != '0', 这个时候, 如果满足条件, 

    1. s[i - 1] 为1或者2, 且当前字符在[0, 6]内 , 新加入的字符可以选择和前一个字符结合, 也可以单独作为一个元素, 结合的话,  有dp[i-2]种选择, 
        $$
        dp = dp[i- 2] +  dp[i- 1 ]
        $$
        

    2. 单独作为一个元素,  dp[i] = dp[i - 1];

```cpp
class Solution {
public:
    int numDecodings(string s) {
        if (s.empty() || s[0] == '0')
            return 0;
        vector<int> dp(s.size(), 0);
        dp[0] = 1;
        for (int i = 1; i < s.size(); i++) {
            if (s[i] == '0') {
                if (s[i - 1] == '1' || s[i - 1] == '2')
                    dp[i] = i > 1 ?  dp[i - 2]  : 1;
                else
                    dp[i] = 0;
            } else {
                if (s[i - 1] == '1' || s[i - 1] == '2' && s[i] >= '1' && s[i] <= '6') {
                    if (i > 1)
                        dp[i] = dp[i - 1] + dp[i - 2];
                    else
                        dp[i] = dp[i - 1] + 1;
                } else 
                    dp[i] = dp[i -1];
            }
            // cout << i << ":" << dp[i] << "\n";
        }

        return dp[s.size() - 1];
    }
};
```